{
  "version": 3,
  "sources": ["../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/index.ts", "../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx"],
  "sourcesContent": ["export {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n} from './RovingFocusGroup';\nexport type { RovingFocusGroupProps, RovingFocusItemProps } from './RovingFocusGroup';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;ACcA,IAAMA,oCAAc;AACpB,IAAMC,sCAAgB;EAAEC,SAAS;EAAOC,YAAY;;AAMpD,IAAMC,mCAAa;AAGnB,IAAM,CAACC,kCAAYC,qCAAeC,2CAA5B,IAAqDC,0CAGzDJ,gCAHyE;AAM3E,IAAM,CAACK,qDAA+BC,wCAAhC,IAA+DC,yCACnEP,kCACA;EAACG;CAFoF;AAiCvF,IAAM,CAACK,2CAAqBC,2CAAtB,IACJJ,oDAAkDL,gCAArB;AAK/B,IAAMU,4CAAmBC,iCAAAA,YACvB,CAACC,OAA2CC,iBAAiB;AAC3D,SACE,iCAAAC,eAAC,iCAAW,UADd;IACuB,OAAOF,MAAMG;KAChC,iCAAAD,eAAC,iCAAW,MADd;IACmB,OAAOF,MAAMG;KAC5B,iCAAAD,eAAC,4CAAD,SAAA,CAAA,GAA0BF,OAD5B;IACmC,KAAKC;GAAtC,CAAA,CADF,CADF;CAHmB;AA2BzB,IAAMG,6CAAuBC,iCAAAA,YAG3B,CAACC,OAA+CC,iBAAiB;AACjE,QAAM,EAAA,yBAAA,aAAA,OAGG,OAHH,KAKJC,kBAAkBC,sBALd,yBAAA,0BAAA,cASJ,GAAGC,WAAH,IACEJ;AACJ,QAAMK,UAAMN,aAAAA,QAA0C,IAA1C;AACZ,QAAMO,eAAeC,0CAAgBN,cAAcI,GAAf;AACpC,QAAMG,YAAYC,0CAAaC,GAAD;AAC9B,QAAM,CAACR,mBAAmB,MAAMS,mBAA1B,IAAiDC,yCAAqB;IAC1EC,MAAMV;IACNW,aAAaC;IACbC,UAAUC;GAH+D;AAK3E,QAAM,CAACC,kBAAkBC,mBAAnB,QAA0CpB,aAAAA,UAAe,KAAf;AAChD,QAAMqB,mBAAmBC,0CAAeC,YAAD;AACvC,QAAMC,WAAWC,oCAAcC,uBAAD;AAC9B,QAAMC,sBAAkB3B,aAAAA,QAAa,KAAb;AACxB,QAAM,CAAC4B,qBAAqBC,sBAAtB,QAAgD7B,aAAAA,UAAe,CAAf;AAEtDA,mBAAAA,WAAgB,MAAM;AACpB,UAAM8B,OAAOxB,IAAIyB;AACjB,QAAID,MAAM;AACRA,WAAKE,iBAAiBC,mCAAaZ,gBAAnC;AACA,aAAO,MAAMS,KAAKI,oBAAoBD,mCAAaZ,gBAAtC;;KAEd;IAACA;GANJ;AAQA,SACE,iCAAAc,eAAC,2CADH;IAEI,OAAOT;IACP;IACA,KAAKjB;IACL;IACA;IACA,iBAAaT,aAAAA;MACVoC,CAAAA,cAAcxB,oBAAoBwB,SAAD;MAClC;QAACxB;;IAFU;IAIb,oBAAgBZ,aAAAA;MAAkB,MAAMoB,oBAAoB,IAAD;MAAQ,CAAA;IAAnD;IAChB,wBAAoBpB,aAAAA;MAClB,MAAM6B;QAAwBQ,CAAAA,cAAcA,YAAY;MAA5B;MAC5B,CAAA;IAFkB;IAIpB,2BAAuBrC,aAAAA;MACrB,MAAM6B;QAAwBQ,CAAAA,cAAcA,YAAY;MAA5B;MAC5B,CAAA;IAFqB;KAKvB,iCAAAF,eAAC,0CAAU,KApBb,SAAA;IAqBI,UAAUhB,oBAAoBS,wBAAwB,IAAI,KAAK;IAC/D,oBAAkBU;KACdjC,YAHN;IAIE,KAAKE;IACL,OAAO;MAAEgC,SAAS;MAAQ,GAAGtC,MAAMuC;;IACnC,aAAaC,0CAAqBxC,MAAMyC,aAAa,MAAM;AACzDf,sBAAgBI,UAAU;KADK;IAGjC,SAASU,0CAAqBxC,MAAM0C,SAAUC,CAAAA,UAAU;AAKtD,YAAMC,kBAAkB,CAAClB,gBAAgBI;AAEzC,UAAIa,MAAME,WAAWF,MAAMG,iBAAiBF,mBAAmB,CAAC1B,kBAAkB;AAChF,cAAM6B,kBAAkB,IAAIC,YAAYhB,mCAAaiB,mCAA7B;AACxBN,cAAMG,cAAcI,cAAcH,eAAlC;AAEA,YAAI,CAACA,gBAAgBI,kBAAkB;AACrC,gBAAMC,QAAQ7B,SAAQ,EAAG8B;YAAQC,CAAAA,SAASA,KAAKC;UAAjC;AACd,gBAAMC,aAAaJ,MAAMK;YAAMH,CAAAA,SAASA,KAAKI;UAA1B;AACnB,gBAAMC,cAAcP,MAAMK;YAAMH,CAAAA,SAASA,KAAKM,OAAO1D;UAAjC;AACpB,gBAAM2D,iBAAiB;YAACL;YAAYG;eAAgBP;YAAOC,OACzDS,OADqB;AAGvB,gBAAMC,iBAAiBF,eAAeG;YAAKV,CAAAA,SAASA,KAAKjD,IAAIyB;UAAtC;AACvBmC,2CAAWF,cAAD;;;AAIdrC,sBAAgBI,UAAU;KAvBC;IAyB7B,QAAQU;MAAqBxC,MAAMkE;MAAQ,MAAM/C,oBAAoB,KAAD;IAAxC;GAlC9B,CAAA,CApBF;CAtCyB;AAsG7B,IAAMgD,kCAAY;AAUlB,IAAMC,2CAAuBrE,iCAAAA,YAC3B,CAACC,OAA0CC,iBAAiB;AAC1D,QAAM,EAAA,yBAAA,YAEQ,MAFR,SAGK,OAHL,WAKJ,GAAGoE,UAAH,IACErE;AACJ,QAAMsE,SAASC,0CAAK;AACpB,QAAMX,KAAKzB,aAAamC;AACxB,QAAME,UAAUC,4CAAsBN,iCAAW1C,uBAAZ;AACrC,QAAMiD,mBAAmBF,QAAQtE,qBAAqB0D;AACtD,QAAMrC,WAAWC,oCAAcC,uBAAD;AAE9B,QAAM,EAAA,oBAAA,sBAAsBkD,IAA0BH;AAEtDzE,mBAAAA,WAAgB,MAAM;AACpB,QAAIwD,WAAW;AACbqB,yBAAkB;AAClB,aAAO,MAAMD,sBAAqB;;KAEnC;IAACpB;IAAWqB;IAAoBD;GALnC;AAOA,SACE,iCAAAzC,eAAC,iCAAW,UADd;IAEI,OAAOT;IACP;IACA;IACA;KAEA,iCAAAS,eAAC,0CAAU,MANb,SAAA;IAOI,UAAUwC,mBAAmB,IAAI;IACjC,oBAAkBF,QAAQnC;KACtBgC,WAHN;IAIE,KAAKpE;IACL,aAAauC,0CAAqBxC,MAAMyC,aAAcE,CAAAA,UAAU;AAG9D,UAAI,CAACY;AAAWZ,cAAMkC,eAAN;;AAEXL,gBAAQM,YAAYlB,EAApB;KAL0B;IAOjC,SAASpB;MAAqBxC,MAAM0C;MAAS,MAAM8B,QAAQM,YAAYlB,EAApB;IAAtB;IAC7B,WAAWpB,0CAAqBxC,MAAM+E,WAAYpC,CAAAA,UAAU;AAC1D,UAAIA,MAAMqC,QAAQ,SAASrC,MAAMsC,UAAU;AACzCT,gBAAQU,eAAR;AACA;;AAGF,UAAIvC,MAAME,WAAWF,MAAMG;AAAe;AAE1C,YAAMqC,cAAcC,qCAAezC,OAAO6B,QAAQnC,aAAamC,QAAQ9D,GAArC;AAElC,UAAIyE,gBAAgBE,QAAW;AAC7B1C,cAAMkC,eAAN;AACA,cAAMzB,QAAQ7B,SAAQ,EAAG8B;UAAQC,CAAAA,SAASA,KAAKC;QAAjC;AACd,YAAIQ,iBAAiBX,MAAMY;UAAKV,CAAAA,SAASA,KAAKjD,IAAIyB;QAA7B;AAErB,YAAIqD,gBAAgB;AAAQpB,yBAAeuB,QAAf;iBACnBH,gBAAgB,UAAUA,gBAAgB,QAAQ;AACzD,cAAIA,gBAAgB;AAAQpB,2BAAeuB,QAAf;AAC5B,gBAAMC,eAAexB,eAAeyB,QAAQ7C,MAAMG,aAA7B;AACrBiB,2BAAiBS,QAAQiB,OACrBC,gCAAU3B,gBAAgBwB,eAAe,CAAhC,IACTxB,eAAe4B,MAAMJ,eAAe,CAApC;;AAONK;UAAW,MAAM3B,iCAAWF,cAAD;QAAjB;;KA5BiB;GAbjC,CAAA,CANF;CAzBuB;AAsF7B,IAAM8B,gDAAuD;EAC3DC,WAAW;EAAQC,SAAS;EAC5BC,YAAY;EAAQC,WAAW;EAC/BC,QAAQ;EAASC,MAAM;EACvBC,UAAU;EAAQC,KAAK;;AAGzB,SAASC,2CAAqBC,KAAaC,KAAiB;AAC1D,MAAIA,QAAQ;AAAO,WAAOD;AAC1B,SAAOA,QAAQ,cAAc,eAAeA,QAAQ,eAAe,cAAcA;;AAKnF,SAASE,qCAAeC,OAA4BC,aAA2BH,KAAiB;AAC9F,QAAMD,MAAMD,2CAAqBI,MAAMH,KAAKC,GAAZ;AAChC,MAAIG,gBAAgB,cAAc;IAAC;IAAa;IAAcC,SAASL,GAArC;AAA2C,WAAOM;AACpF,MAAIF,gBAAgB,gBAAgB;IAAC;IAAW;IAAaC,SAASL,GAAlC;AAAwC,WAAOM;AACnF,SAAOhB,8CAAwBU,GAAD;;AAGhC,SAASO,iCAAWC,YAA2B;AAC7C,QAAMC,6BAA6BC,SAASC;AAC5C,aAAWC,aAAaJ,YAAY;AAElC,QAAII,cAAcH;AAA4B;AAC9CG,cAAUC,MAAV;AACA,QAAIH,SAASC,kBAAkBF;AAA4B;;;AAQ/D,SAASK,gCAAaC,OAAYC,YAAoB;AACpD,SAAOD,MAAME;IAAI,CAACC,GAAGC,UAAUJ,OAAOC,aAAaG,SAASJ,MAAMK,MAA9B;EAA7B;;AAGT,IAAMC,4CAAOC;AACb,IAAMC,4CAAOC;",
  "names": ["ENTRY_FOCUS", "EVENT_OPTIONS", "bubbles", "cancelable", "GROUP_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createRovingFocusGroupContext", "createRovingFocusGroupScope", "createContextScope", "RovingFocusProvider", "useRovingFocusContext", "RovingFocusGroup", "React", "props", "forwardedRef", "$98Iye$createElement", "__scopeRovingFocusGroup", "RovingFocusGroupImpl", "React", "props", "forwardedRef", "currentTabStopId", "currentTabStopIdProp", "groupProps", "ref", "composedRefs", "useComposedRefs", "direction", "useDirection", "dir", "setCurrentTabStopId", "useControllableState", "prop", "defaultProp", "defaultCurrentTabStopId", "onChange", "onCurrentTabStopIdChange", "isTabbingBackOut", "setIsTabbingBackOut", "handleEntryFocus", "useCallbackRef", "onEntryFocus", "getItems", "useCollection", "__scopeRovingFocusGroup", "isClickFocusRef", "focusableItemsCount", "setFocusableItemsCount", "node", "current", "addEventListener", "ENTRY_FOCUS", "removeEventListener", "$98Iye$createElement", "tabStopId", "prevCount", "orientation", "outline", "style", "composeEventHandlers", "onMouseDown", "onFocus", "event", "isKeyboardFocus", "target", "currentTarget", "entryFocusEvent", "CustomEvent", "EVENT_OPTIONS", "dispatchEvent", "defaultPrevented", "items", "filter", "item", "focusable", "activeItem", "find", "active", "currentItem", "id", "candidateItems", "Boolean", "candidateNodes", "map", "focusFirst", "onBlur", "ITEM_NAME", "RovingFocusGroupItem", "itemProps", "autoId", "useId", "context", "useRovingFocusContext", "isCurrentTabStop", "onFocusableItemRemove", "onFocusableItemAdd", "preventDefault", "onItemFocus", "onKeyDown", "key", "shiftKey", "onItemShiftTab", "focusIntent", "getFocusIntent", "undefined", "reverse", "currentIndex", "indexOf", "loop", "wrapArray", "slice", "setTimeout", "MAP_KEY_TO_FOCUS_INTENT", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "PageUp", "Home", "PageDown", "End", "getDirectionAwareKey", "key", "dir", "getFocusIntent", "event", "orientation", "includes", "undefined", "focusFirst", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "document", "activeElement", "candidate", "focus", "wrapArray", "array", "startIndex", "map", "_", "index", "length", "Root", "RovingFocusGroup", "Item", "RovingFocusGroupItem"]
}
