{
  "version": 3,
  "sources": ["../../../node_modules/@radix-ui/react-tooltip/dist/packages/react/tooltip/src/index.ts", "../../../node_modules/@radix-ui/react-tooltip/dist/packages/react/tooltip/src/Tooltip.tsx", "../../../app/shared/ui/Tooltip/Tooltip.tsx"],
  "sourcesContent": ["export {\n  createTooltipScope,\n  //\n  TooltipProvider,\n  Tooltip,\n  TooltipTrigger,\n  TooltipPortal,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Provider,\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Arrow,\n} from './Tooltip';\nexport type {\n  TooltipProps,\n  TooltipTriggerProps,\n  TooltipPortalProps,\n  TooltipContentProps,\n  TooltipArrowProps,\n} from './Tooltip';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Slottable } from '@radix-ui/react-slot';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype ScopedProps<P = {}> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope('Tooltip', [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'TooltipProvider';\nconst DEFAULT_DELAY_DURATION = 700;\nconst TOOLTIP_OPEN = 'tooltip.open';\n\ntype TooltipProviderContextValue = {\n  isOpenDelayed: boolean;\n  delayDuration: number;\n  onOpen(): void;\n  onClose(): void;\n  onPointerInTransitChange(inTransit: boolean): void;\n  isPointerInTransitRef: React.MutableRefObject<boolean>;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipProviderContextProvider, useTooltipProviderContext] =\n  createTooltipContext<TooltipProviderContextValue>(PROVIDER_NAME);\n\ninterface TooltipProviderProps {\n  children: React.ReactNode;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst TooltipProvider: React.FC<TooltipProviderProps> = (\n  props: ScopedProps<TooltipProviderProps>\n) => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children,\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n\n  return (\n    <TooltipProviderContextProvider\n      scope={__scopeTooltip}\n      isOpenDelayed={isOpenDelayed}\n      delayDuration={delayDuration}\n      onOpen={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        setIsOpenDelayed(false);\n      }, [])}\n      onClose={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(\n          () => setIsOpenDelayed(true),\n          skipDelayDuration\n        );\n      }, [skipDelayDuration])}\n      isPointerInTransitRef={isPointerInTransitRef}\n      onPointerInTransitChange={React.useCallback((inTransit: boolean) => {\n        isPointerInTransitRef.current = inTransit;\n      }, [])}\n      disableHoverableContent={disableHoverableContent}\n    >\n      {children}\n    </TooltipProviderContextProvider>\n  );\n};\n\nTooltipProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: 'closed' | 'delayed-open' | 'instant-open';\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onTriggerEnter(): void;\n  onTriggerLeave(): void;\n  onOpen(): void;\n  onClose(): void;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipContextProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened. This will\n   * override the prop with the same name passed to Provider.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp,\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent =\n    disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        providerContext.onOpen();\n\n        // as `onChange` is called within a lifecycle method we\n        // avoid dispatching via `dispatchDiscreteCustomEvent`.\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n      onOpenChange?.(open);\n    },\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? (wasOpenDelayedRef.current ? 'delayed-open' : 'instant-open') : 'closed';\n  }, [open]);\n\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    setOpen(false);\n  }, [setOpen]);\n\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(openTimerRef.current);\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipContextProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onTriggerEnter={React.useCallback(() => {\n          if (providerContext.isOpenDelayed) handleDelayedOpen();\n          else handleOpen();\n        }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen])}\n        onTriggerLeave={React.useCallback(() => {\n          if (disableHoverableContent) {\n            handleClose();\n          } else {\n            // Clear the timer in case the pointer leaves the trigger before the tooltip is opened.\n            window.clearTimeout(openTimerRef.current);\n          }\n        }, [handleClose, disableHoverableContent])}\n        onOpen={handleOpen}\n        onClose={handleClose}\n        disableHoverableContent={disableHoverableContent}\n      >\n        {children}\n      </TooltipContextProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const ref = React.useRef<TooltipTriggerElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n    const isPointerDownRef = React.useRef(false);\n    const hasPointerMoveOpenedRef = React.useRef(false);\n    const handlePointerUp = React.useCallback(() => (isPointerDownRef.current = false), []);\n\n    React.useEffect(() => {\n      return () => document.removeEventListener('pointerup', handlePointerUp);\n    }, [handlePointerUp]);\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          // We purposefully avoid adding `type=button` here because tooltip triggers are also\n          // commonly anchors and the anchor `type` attribute signifies MIME type.\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedRefs}\n          onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n            if (event.pointerType === 'touch') return;\n            if (\n              !hasPointerMoveOpenedRef.current &&\n              !providerContext.isPointerInTransitRef.current\n            ) {\n              context.onTriggerEnter();\n              hasPointerMoveOpenedRef.current = true;\n            }\n          })}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => {\n            context.onTriggerLeave();\n            hasPointerMoveOpenedRef.current = false;\n          })}\n          onPointerDown={composeEventHandlers(props.onPointerDown, () => {\n            isPointerDownRef.current = true;\n            document.addEventListener('pointerup', handlePointerUp, { once: true });\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            if (!isPointerDownRef.current) context.onOpen();\n          })}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          onClick={composeEventHandlers(props.onClick, context.onClose)}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'TooltipPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createTooltipContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface TooltipPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipPortal: React.FC<TooltipPortalProps> = (props: ScopedProps<TooltipPortalProps>) => {\n  const { __scopeTooltip, forceMount, children, container } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return (\n    <PortalProvider scope={__scopeTooltip} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nTooltipPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n    const { forceMount = portalContext.forceMount, side = 'top', ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.disableHoverableContent ? (\n          <TooltipContentImpl side={side} {...contentProps} ref={forwardedRef} />\n        ) : (\n          <TooltipContentHoverable side={side} {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\n\ntype TooltipContentHoverableElement = TooltipContentImplElement;\ninterface TooltipContentHoverableProps extends TooltipContentImplProps {}\n\nconst TooltipContentHoverable = React.forwardRef<\n  TooltipContentHoverableElement,\n  TooltipContentHoverableProps\n>((props: ScopedProps<TooltipContentHoverableProps>, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef<TooltipContentHoverableElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState<Polygon | null>(null);\n\n  const { trigger, onClose } = context;\n  const content = ref.current;\n\n  const { onPointerInTransitChange } = providerContext;\n\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n\n  const handleCreateGraceArea = React.useCallback(\n    (event: PointerEvent, hoverTarget: HTMLElement) => {\n      const currentTarget = event.currentTarget as HTMLElement;\n      const exitPoint = { x: event.clientX, y: event.clientY };\n      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n      setPointerGraceArea(graceArea);\n      onPointerInTransitChange(true);\n    },\n    [onPointerInTransitChange]\n  );\n\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = (event: PointerEvent) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event: PointerEvent) => handleCreateGraceArea(event, trigger);\n\n      trigger.addEventListener('pointerleave', handleTriggerLeave);\n      content.addEventListener('pointerleave', handleContentLeave);\n      return () => {\n        trigger.removeEventListener('pointerleave', handleTriggerLeave);\n        content.removeEventListener('pointerleave', handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event: PointerEvent) => {\n        const target = event.target as HTMLElement;\n        const pointerPosition = { x: event.clientX, y: event.clientY };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener('pointermove', handleTrackPointerGrace);\n      return () => document.removeEventListener('pointermove', handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n\n  return <TooltipContentImpl {...props} ref={composedRefs} />;\n});\n\nconst [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] =\n  createTooltipContext(TOOLTIP_NAME, { isInside: false });\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends Omit<PopperContentProps, 'onPlaced'> {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `Tooltip`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const { onClose } = context;\n\n    // Close this tooltip if another one opens\n    React.useEffect(() => {\n      document.addEventListener(TOOLTIP_OPEN, onClose);\n      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [onClose]);\n\n    // Close the tooltip if the trigger is scrolled\n    React.useEffect(() => {\n      if (context.trigger) {\n        const handleScroll = (event: Event) => {\n          const target = event.target as HTMLElement;\n          if (target?.contains(context.trigger)) onClose();\n        };\n        window.addEventListener('scroll', handleScroll, { capture: true });\n        return () => window.removeEventListener('scroll', handleScroll, { capture: true });\n      }\n    }, [context.trigger, onClose]);\n\n    return (\n      <DismissableLayer\n        asChild\n        disableOutsidePointerEvents={false}\n        onEscapeKeyDown={onEscapeKeyDown}\n        onPointerDownOutside={onPointerDownOutside}\n        onFocusOutside={(event) => event.preventDefault()}\n        onDismiss={onClose}\n      >\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom properties\n            ...{\n              '--radix-tooltip-content-transform-origin': 'var(--radix-popper-transform-origin)',\n              '--radix-tooltip-content-available-width': 'var(--radix-popper-available-width)',\n              '--radix-tooltip-content-available-height': 'var(--radix-popper-available-height)',\n              '--radix-tooltip-trigger-width': 'var(--radix-popper-anchor-width)',\n              '--radix-tooltip-trigger-height': 'var(--radix-popper-anchor-height)',\n            },\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenContentContextProvider scope={__scopeTooltip} isInside={true}>\n            <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n              {ariaLabel || children}\n            </VisuallyHiddenPrimitive.Root>\n          </VisuallyHiddenContentContextProvider>\n        </PopperPrimitive.Content>\n      </DismissableLayer>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(\n      ARROW_NAME,\n      __scopeTooltip\n    );\n    // if the arrow is inside the `VisuallyHidden`, we don't want to render it all to\n    // prevent issues in positioning the arrow due to the duplicate\n    return visuallyHiddenContentContext.isInside ? null : (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    );\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype Side = NonNullable<TooltipContentProps['side']>;\n\nfunction getExitSideFromRect(point: Point, rect: DOMRect): Side {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return 'left';\n    case right:\n      return 'right';\n    case top:\n      return 'top';\n    case bottom:\n      return 'bottom';\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction getPaddedExitPoints(exitPoint: Point, exitSide: Side, padding = 5) {\n  const paddedExitPoints: Point[] = [];\n  switch (exitSide) {\n    case 'top':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'bottom':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y - padding }\n      );\n      break;\n    case 'left':\n      paddedExitPoints.push(\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'right':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x - padding, y: exitPoint.y + padding }\n      );\n      break;\n  }\n  return paddedExitPoints;\n}\n\nfunction getPointsFromRect(rect: DOMRect) {\n  const { top, right, bottom, left } = rect;\n  return [\n    { x: left, y: top },\n    { x: right, y: top },\n    { x: right, y: bottom },\n    { x: left, y: bottom },\n  ];\n}\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\n// Returns a new array of points representing the convex hull of the given set of points.\n// https://www.nayuki.io/page/convex-hull-algorithm\nfunction getHull<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  const newPoints: Array<P> = points.slice();\n  newPoints.sort((a: Point, b: Point) => {\n    if (a.x < b.x) return -1;\n    else if (a.x > b.x) return +1;\n    else if (a.y < b.y) return -1;\n    else if (a.y > b.y) return +1;\n    else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction getHullPresorted<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  if (points.length <= 1) return points.slice();\n\n  const upperHull: Array<P> = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();\n      else break;\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n\n  const lowerHull: Array<P> = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();\n      else break;\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n\n  if (\n    upperHull.length === 1 &&\n    lowerHull.length === 1 &&\n    upperHull[0].x === lowerHull[0].x &&\n    upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\nconst Provider = TooltipProvider;\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Portal = TooltipPortal;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  TooltipProvider,\n  Tooltip,\n  TooltipTrigger,\n  TooltipPortal,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Provider,\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Arrow,\n};\nexport type {\n  TooltipProps,\n  TooltipTriggerProps,\n  TooltipPortalProps,\n  TooltipContentProps,\n  TooltipArrowProps,\n};\n", "// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"app/shared/ui/Tooltip/Tooltip.tsx\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"app/shared/ui/Tooltip/Tooltip.tsx\");\n  import.meta.hot.lastModified = \"1706588338084.4287\";\n}\n// REMIX HMR END\n\nimport * as TooltipPrimitive from '@radix-ui/react-tooltip';\nimport * as React from 'react';\nimport { cn } from '~/app/shared/lib/utils/index.ts';\nconst TooltipProvider = TooltipPrimitive.Provider;\nconst Tooltip = TooltipPrimitive.Root;\nconst TooltipTrigger = TooltipPrimitive.Trigger;\nconst TooltipContent = React.forwardRef(_c = ({\n  className,\n  sideOffset = 4,\n  ...props\n}, ref) => <TooltipPrimitive.Content ref={ref} sideOffset={sideOffset} className={cn('z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2', className)} {...props} />);\n_c2 = TooltipContent;\nTooltipContent.displayName = TooltipPrimitive.Content.displayName;\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };\nvar _c, _c2;\n$RefreshReg$(_c, \"TooltipContent$React.forwardRef\");\n$RefreshReg$(_c2, \"TooltipContent\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;"],
  "mappings": "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",
  "names": ["createTooltipContext", "createTooltipScope", "createContextScope", "createPopperScope", "usePopperScope", "PROVIDER_NAME", "DEFAULT_DELAY_DURATION", "TOOLTIP_OPEN", "TooltipProviderContextProvider", "useTooltipProviderContext", "TooltipProvider", "props", "children", "isOpenDelayed", "setIsOpenDelayed", "React", "isPointerInTransitRef", "skipDelayTimerRef", "skipDelayTimer", "current", "window", "clearTimeout", "$8wepK$createElement", "__scopeTooltip", "setTimeout", "skipDelayDuration", "inTransit", "TOOLTIP_NAME", "TooltipContextProvider", "useTooltipContext", "createTooltipContext", "Tooltip", "props", "open", "openProp", "disableHoverableContent", "disableHoverableContentProp", "delayDuration", "delayDurationProp", "providerContext", "useTooltipProviderContext", "__scopeTooltip", "popperScope", "usePopperScope", "trigger", "setTrigger", "React", "contentId", "useId", "openTimerRef", "wasOpenDelayedRef", "setOpen", "useControllableState", "prop", "defaultProp", "defaultOpen", "onChange", "onOpen", "document", "dispatchEvent", "CustomEvent", "TOOLTIP_OPEN", "onClose", "onOpenChange", "stateAttribute", "current", "handleOpen", "window", "clearTimeout", "handleClose", "handleDelayedOpen", "setTimeout", "$8wepK$createElement", "isOpenDelayed", "children", "TRIGGER_NAME", "TooltipTrigger", "React", "props", "forwardedRef", "triggerProps", "context", "useTooltipContext", "__scopeTooltip", "providerContext", "useTooltipProviderContext", "popperScope", "usePopperScope", "ref", "composedRefs", "useComposedRefs", "onTriggerChange", "isPointerDownRef", "hasPointerMoveOpenedRef", "handlePointerUp", "current", "document", "removeEventListener", "$8wepK$createElement", "open", "contentId", "undefined", "stateAttribute", "composeEventHandlers", "onPointerMove", "event", "pointerType", "isPointerInTransitRef", "onTriggerEnter", "onPointerLeave", "onTriggerLeave", "onPointerDown", "addEventListener", "once", "onFocus", "onOpen", "onBlur", "onClose", "onClick", "PORTAL_NAME", "PortalProvider", "usePortalContext", "createTooltipContext", "forceMount", "undefined", "CONTENT_NAME", "TooltipContent", "React", "props", "forwardedRef", "portalContext", "usePortalContext", "__scopeTooltip", "forceMount", "contentProps", "context", "useTooltipContext", "$8wepK$createElement", "open", "disableHoverableContent", "TooltipContentHoverable", "providerContext", "useTooltipProviderContext", "ref", "composedRefs", "useComposedRefs", "pointerGraceArea", "setPointerGraceArea", "onClose", "content", "current", "onPointerInTransitChange", "handleRemoveGraceArea", "handleCreateGraceArea", "event", "hoverTarget", "currentTarget", "exitPoint", "x", "clientX", "y", "clientY", "exitSide", "getExitSideFromRect", "getBoundingClientRect", "paddedExitPoints", "getPaddedExitPoints", "hoverTargetPoints", "getPointsFromRect", "graceArea", "getHull", "trigger", "handleTriggerLeave", "handleContentLeave", "addEventListener", "removeEventListener", "handleTrackPointerGrace", "target", "pointerPosition", "hasEnteredTarget", "contains", "isPointerOutsideGraceArea", "isPointInPolygon", "document", "VisuallyHiddenContentContextProvider", "useVisuallyHiddenContentContext", "createTooltipContext", "TOOLTIP_NAME", "isInside", "TooltipContentImpl", "ariaLabel", "popperScope", "usePopperScope", "TOOLTIP_OPEN", "handleScroll", "window", "capture", "preventDefault", "stateAttribute", "style", "children", "contentId", "getExitSideFromRect", "point", "rect", "top", "Math", "abs", "y", "bottom", "right", "x", "left", "min", "Error", "getPaddedExitPoints", "exitPoint", "exitSide", "padding", "paddedExitPoints", "push", "getPointsFromRect", "isPointInPolygon", "polygon", "inside", "i", "j", "length", "xi", "yi", "xj", "yj", "intersect", "getHull", "points", "newPoints", "slice", "sort", "a", "b", "getHullPresorted", "upperHull", "p", "q", "r", "pop", "lowerHull", "concat", "Provider", "TooltipProvider", "Root", "Tooltip", "Trigger", "TooltipTrigger", "Content", "TooltipContent"]
}
